\chapter{Fortgeschrittene Synchronisationskonzepte in Java}


\section{Semaphore}

Der \textbf{Semaphor} (engl. ``semaphore``) repräsentiert ein klassisches Synchronisationskonzept.\\

\noindent
Das abstrakte Konzept dahinter: Ein Semaphor hat einen Wert des Typs \code{int}, der nie $<\ 0$ werden kann.\\
Die Methoden \code{p()} (nl.: \textit{passeeren}, auch engl. \textit{down} oder \textit{acquire}) bzw. \code{v()} (nl. \textit{frijgeven}, auch engl. \textit{up} oder \textit{release}) dienen zum Herunter- bzw. Hochzählen des Attributs.\\

\noindent
Ein Thread wird \textbf{blockiert}, wenn bei seinem Aufruf von \code{p()} der Attributwert negativ werden würde.

\subsection{Einfache Semaphore für den gegenseitigen Ausschluss}

Semaphoren werden häufig zur Realisierung des gegenseitigen Ausschlusses realisiert $\rightarrow$ ein Programmstück kann nur von einem Thread gleichzeitig ausgeführt werden.\\

\noindent
Hierzu werden sogenannte \textbf{Mutex Semaphors} (\textit{Mutex} = \textit{Mutual Exclusion}) verwendet:\\
Die Semaphor wird hierzu mit dem Wert $1$ initialisiert - ruft ein Thread $t_1$ \code{p()} auf und zählt dabei den Wert des Semaphors herunter, müssen ankommende Threads $t$ warten, bis der Wert durch die Freigabe von $t_1$ wieder erhöht und so der kritische Bereich\footnote{
    \textit{kritischer Bereich}: das Programmstück, das zu einem Zeitpunkt nur von höchstens einem Thread ausgeführt werden darf (vgl.~\cite[102]{Oec22}).
} wieder freigegeben wird\footnote{eine \textit{binäre Semaphore} kann nur die Werte $0$ und $1$ bzw. $true$ und $false$ annehmen. In \textit{v()} kann vor dem \textit{notify} überprüft werden, ob sich die Semaphore gerade überhaupt im ``gesperrten`` Zustand befindet}.\\

\noindent
In dem folgenden Beispiel wird \underlien{ein} Semaphor für 3 verschiedene Objekte desselben Typs verwendet.\\
Der Semaphor stellt sicher, dass nur jeweils ein Thread das Programmstück in \code{enter()} (über die $3$ verschiedenen Objekte verteilt) ausführen kann. \\


\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    fontsize=\small,
    frame=lines,
    framesep=2mm]{java}
    public class MutexSemaphorDemo {

        static class MutexSemaphor {
            private int n = 1;
            public synchronized void p() {
                while (n < 1) {
                    try {
                        wait();
                    } catch (InterruptedException ignored) {}
                }
                n--;
            }

            public synchronized void v() {
                n++;
                notify();
            }
        }

        static class Waiter extends Thread{
            MutexSemaphor sem;
            String name;
            public Waiter(MutexSemaphor s, String n) {
                sem = s;
                name = n;
                start();
            }

            public void enter() {
                    String currentThread = Thread.currentThread().getName();
                    sem.p();
                    System.out.println(currentThread + " enters [" + name + "]!");
                    try {
                        Thread.currentThread().sleep((int) (Math.random() * 100));
                    } catch (InterruptedException ignored) {}
                    System.out.println(currentThread + " exits [" + name + "]");
                    sem.v();
            }
        }

        public static void main(String[] args) throws InterruptedException {
            MutexSemaphor sem = new MutexSemaphor();
            Waiter waiter1 = new Waiter(sem, "w1");
            Waiter waiter2 = new Waiter(sem, "w2");
            Waiter waiter3 = new Waiter(sem, "w3");
            Thread t1 = new Thread(waiter1::enter);
            Thread t2 = new Thread(waiter2::enter);
            Thread t3 = new Thread(waiter3::enter);

            t1.start();t2.start();t3.start();
            t1.join();t2.join();t3.join();
        }
    }
\end{minted}\\

Eine mögliche Ausgabe für das Programm ist:\\

\noindent
\begin{minted}[mathescape,
    numbersep=5pt,
    gobble=2,
    frame=lines,
    framesep=2mm]{bash}
    Thread-3 enters critical section of [w1]!
    Thread-3 exits [w1]
    Thread-4 enters critical section of [w2]!
    Thread-4 exits [w2]
    Thread-5 enters critical section of [w3]!
    Thread-5 exits [w3]
\end{minted}\\

\noindent
Wäre \code{enter} hingegen bloß \code{synchronized} und es würde kein Semaphor verwendet, würden die Threads jeweils parallel \code{enter} ausführen, die Ausgabe lautet dann in etwa:


\begin{minted}[mathescape,
    numbersep=5pt,
    gobble=2,
    frame=lines,
    framesep=2mm]{bash}
    Thread-3 enters critical section of [w1]!
    Thread-4 enters critical section of [w2]!
    Thread-5 enters critical section of [w3]!
    Thread-4 exits [w2]
    Thread-3 exits [w1]
    Thread-5 exits [w3]
\end{minted}\\

\subsection{Semaphore zur Herstellung vorgegebener Ausführungsreihenfolgen}

Neben gegenseitigem Ausschluss können Semaphoren auch eingesetzt werden, um die \textbf{Ausführungsreihenfolge} von Threads festzulegen\footnote{ausführliches Beispiel in~\cite[104]{Oec22}}.

\subsection{Additive Semaphore}
\textbf{Additive Semaphore} erlauben es aufrufenden Threads, den Wert einer Semaphore um ein gewisses $\Delta\ (\geq\ 1)$ herunterzuzählen.\\

\noindent
Dabei ändert sich die Wartebedingung in des Semaphors von

\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    frame=lines,
    framesep=2mm]{java}
    while (n == 0) {
        //...
    }
\end{minted}\\

zu

\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    frame=lines,
    framesep=2mm]{java}
    while (n - x < 0) {
        //...
    }
\end{minted}\\

\noindent
Durch die parametrisierte Wertebedingung ist es nötig, wartende Threads mittels \code{notifyAll()} aus der Warteschlange zu holen: Erstens kann es mehrere Threads geben, bei denen insgesamt $\sum_{i=1}^{n} \Delta_i\ \geq\ 0$ sein kann (es dürfen dann mehrere Threads parallel in den kritischen Bereich); zweitens kann die Wartebedingung basierend auf dem $x$ für Threads unterschiedlich sein - sollte nur \code{notify} verwendet werden kann es passieren, dass ein Thread direkt danach wieder in die Warteschlange kommt - und infolgedessen kein anderer Thread mehr in den kritischen Bereich, und kein Aufruf von \code{v()} mehr stattfindet.\\

\indent
Selbstverständlich sollte sein, dass der Wert des Semaphors \textbf{auf einen Schlag} (durch Subtraktion / Addition) verändert wird, ansonsten kann es zu einer \textbf{Verklemmungssituation} kommen, wenn der Wert inkrementiert/dekrementiert wird (vgl.~\cite[109]{Oec22}).

\subsection{Semaphorgruppen}

Die grundlegende Eigenschaft von additiven Semaphoren, den Wert eines Semaphores auf einen Schlag zu ändern, ist Motivation für die Einführung von \textbf{Semaphorgruppen}.\\

\noindent
Semaphorgruppen werden nicht als Felder von Semaphoren angelegt, sondern eine Semaphorgruppe enthält ein Feld von Werten, auf dem operiert wird.\\

\noindent
Jeder Eintrag in dem Feld repräsentiert ein Mitglied der Semaphorgruppe.


\noindent
Auf die Implementierung von \code{p()}/\code{v()} wird hierbei verzichtet - stattdessen gibt es eine Methode mit einer Signatur ähnlich zu

\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    frame=none,
    framesep=2mm]{java}
    public synchronized void changeValues(int[] deltas)
\end{minted}\\

\noindent
Die Methode schiebt so lange einen Thread in eine Warteschlange, bis die Wartebedingung nicht mehr erfüllt ist - hierbei wird dann jeder Index von der Semaphore wie folgt überprüft:


\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    frame=none,
    framesep=2mm]{java}
    if (values[i] + delta[i] < 0) {
        return false
    }
\end{minted}\\

überprüft: Änderungen werden dann nur durchgeführt, wenn nach der Änderung die Werte aller Semaphore der Gruppe nicht negativ sind (vgl.~\cite[109](Oec22)).\\

\noindent
Wie bei der additiven Semaphore ist es nötig, Threads über \code{notifyAll()} aus der Warteschlange zu holen - ansonsten kann es auch hier vorkommen, dass ein Thread, der weiterlaufen könnte, nicht geweckt wird.


\subsection{Notizen zu den Übungen}

Die Abfrage von Außen auf Listen/Felder von Threads, die sich derzeitig in der Warteschlange befinden, sollte \code{synchronized} erfolgen.
Außerdem sollte eine Kopie der Listen zurückgegeben werden, um Manipulation an der tatsächlichen Liste zu verhindern.\\

\noindent
Bei Exceptions, die nicht abgefangen werden, sorg \code{finally} für ein Ausführen des durch \textit{finally} eingeleiteten Anweisungsblock auch im Fall einer Exception\footnote{
Java Language Specification - 14.20.2. Execution of try-finally and try-catch-finally : \url{https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-14.20.2} - abgerufen 26.01.2024
}

\begin{minted}[mathescape,
    linenos,
    numbersep=5pt,
    gobble=2,
    fontsize=\small,
    frame=lines,
    framesep=2mm]{java}
    public class TryCatchDemo {

        public String m1(boolean exc) {
            try {

                System.out.println("try 1.");

                if (exc) {
                    throw new Exception();
                }
                System.out.println("try 2.");

                return "foo";

            } catch (Exception e) {

                return "Exception.";

            } finally {
                System.out.println("finally.");
            }
        }

        public static void main(String[] args) {
           TryCatchDemo demo = new TryCatchDemo();
           System.out.println(demo.m1(false));
           System.out.println();
           System.out.println(demo.m1(true));
        }

    }
\end{minted}\\

Die Ausgabe des Programms lautet:


\noindent
\begin{minted}[mathescape,
    numbersep=5pt,
    gobble=2,
    frame=lines,
    framesep=2mm]{bash}
    try 1.
    try 2.
    finally.
    foo

    try 1.
    finally.
    Exception.
\end{minted}\\


\section{Message Queues}

\subsection{Verallgemeinerung des Erzeuger-Verbraucher-Problems}

Bei \textbf{Message Queues} bleiben Nachrichten als Einheiten erhalten (\textbf{nachrichtenorientierte Kommunikation}, bspw. \textbf{UDP}\footnote{User Datagram Protocol}).\\

\noindent
\textbf{Pipes} repräsentieren \textbf{datenstromorientierte Kommunikationsmodelle} (bspw. \textbf{TCP}\footnote{Transmission Control Protocol})  - der Empfänger sieht nicht, in welchen Portionen die Daten gesendet werden.\\

\noindent
Eine Message Queue besitzt einen \textbf{Puffer}, der entweder viele kleine oder wenig große Nachrichten entgegennehmen kann.\\

\noindent
Bei \textbf{Message Queues} werden die Nachrichten in ihrer Gesamtheit in Feldern gespeichert (bspw.~\code{byte[][]}).\\

\noindent
Bei \textbf{Pipes} werden Nachrichten in eindimensionalen Feldern (bspw.~\code{byte[]}) gespeichert (in zyklischer Weise) - dadurch sind Nachrichtengrenzen nicht zu erkennen.\\

\noindent
Das Senden bei Pipes erfolgt i.d.R. als unteilbare Aktion.
\begin{itemize}
    \item Wenn die Nachricht größer ist als der \underline{im Puffer verbleibende Platz}, wird gewartet, bis der Platz frei ist - dann wird \textbf{auf einen Schlag} in den Puffer kopiert
    \item Ist die Nachricht länger als \underline{die Größe des Puffers}, wird die Nachricht geteilt und in Portionen gesendet - dadurch kann es vorkommen, dass Nachrichtenteile durchgemischt werden; sind die Nachrichtenteile nicht größer als die Pufferlänge, befinden sie sich komplett im Puffer;  umgekehrt ist es möglich, dass Stücke von Nachrichtenteilen ``durchgemischt`` werden (vgl.~\cite[117 f.]{Oec22}).
\end{itemize}

Beim Empfangen wird nur so lange gewartet, bis der Puffer nicht mehr leer ist:
\begin{itemize}
    \item der Empfänger gibt an, wie viele Bytes ($n$) er lesen möchte.
    \item ist der Puffer komplett leer, wird mit dem Lesen gewartet, bis Daten im Puffer sind.
    \item Es werden $n$ Daten aus dem Puffer gelesen - sind weniger als $n$ Daten im Puffer, werden auch nur soviele Daten gelesen (die Daten werden hierbei in ein Feld passender Länge kopiert).
\end{itemize}

\section{Philosophen-Problem}
  - keine Notizen -

\section{Leser-Schreiber-Problem}

\textbf{Leser-Schreiber-Problem}: Es soll lesen erlaubt sein von beliebig vielen Threads, aber die Änderung des Objekts durch schreibende Zugriffe darf nur von einem Thread aus geschehen.\\

\noindent
Wenn alle Zugriffe \textbf{synchron} sein müssen, würde das Objekt beim Lesen als auch beim Schreiben blockiert - das schränkt die Parallelität ein, vor allem, wenn der Lesevorgang länger dauert und das Objekt somit nicht aktualisiert werden kann.\\

\noindent
$\rightarrow$ Es muss eine Lösung gefunden werden, so dass mehrere Threads lesen, aber nur ein Thread schreiben kann.

Zur Lösung sind verschiedene Strategien denkbar:

\begin{itemize}
    \item Bevorzugung der Leser, falls es darauf ankommt, dass die Leser schnell Zugriff auf die Daten erhalten, und die Aktualität der Daten weniger wichtig ist
    \item Bevorzugung der Schreiber, falls die Aktualität der Daten wichtiger ist
\end{itemize}\\

\noindent
Die Strategien können nur dann sinnvoll eingesetzt werden, falls kein Thread unerwünscht lange auf seinen Zugriff warten muss.\\
Kann eine gewisse Wartezeit für Leser/Schreiber nicht garantiert werden, bietet sich eine strengere Strategie an: Zugriffswünsche landen in einer Warteschlange, immer der zuerst eingefügte wird abgearbeitet (\textbf{FIFO}).


\section{Schablonen zur Nutzung der Synchronisationsprimitive und Konsistenzbetrachtungen}

Der \textbf{Zustand} eines Objektes wird durch die Werte seiner Attribute beschrieben.\\

\noindent
Gewisse Konsistenzbedingungen\footnote{bestimmte Invarianten bzw. Integritätsbedingungen} gelten für manche solcher Attribute immer $\rightarrow$ das Ändern solcher Attribute führt ein Objekt von einen konsistenten Zustand in einen anderen\footnote{
Konsistenzbedingungen können währen der Überführung eines Objektes in einen anderen Zustand verletzt werden, weshalb man bspw. Zugriffsmodifizierer wie \testit{private} verwendet.
}.\\

\noindent
Wenn mehrere Threads schreibend auf ein Objekt zugreifen, muss die durchgehende Konsistenz des Objektes gewährleistet sein, jeder Thread muss immer ein Objekt vorfinden, für das die Konsistenzbedingungen gelten.\\

\noindent
In einigen Fällen ist die Änderung des Zustands an eine bestimmte Bedingung geknüpft, die als \textbf{Wartebedingung} überprüft werden kann - diese Bedingung sollte in einer \code{while}-Schleife als Ausdruck verwendet werden, damit die Bedingung nach Freigabe erneut überprüft werden kann (sie kann zwischenzeitlich wieder geändert worden sein).\\

\noindent
Wenn nach einer Zustandsänderung wartende Threads weiterlaufen können, sollten diese im Anschluss mittels \code{notify()}/\code{notifyAll} wieder geweckt werden - je nach Implementierung unterscheidet sich das aber, bspw. wenn \textbf{Additive Semaphoren} genutzt werden: Die Zustandsänderung des Zählers bewirkt nicht gleich für alle Threads ein weiterlaufen.\\

\noindent
Komplexe Wartebedingungen implementiert man in einer eigenen Methode.\\

\noindent
Jede Methode einer Klasse (die öffentlich ist) muss sicherstellen, dass das Objekt nach Verlassen der Methode wieder in einem konsistenten Zustand ist.\\

\noindent
Exceptions sollten nicht zu einem inkonsistenten Zustand führen. Hier sollte \code{finally} zur Wahrung der Konsistenz genutzt werden.

\blockquote[{\cite[142]{Oec22}}]{
Es ist darauf zu achten, dass nach der Initialisierung und bei jeder Freigabe einer Sperre der Objektzustand konsistent ist, denn dann kann man davon ausgehen, dass der Zustand auch bei jedem Setzen einer Sperre konsistent ist.
}

Weiter stellt \cite{Oec22} 6 Schablonen vor, die für verschiedene Kategorien von \code{synchronized}-Methoden verwendet werden können:

\begin{itemize}
    \item lesende Methoden ohne \code{wait}
    \item lesende Methoden mit \code{wait}
    \item schreibende Methoden ohne \code{wait} und ohne \code{notify}/\code{notifyAll}
    \item schreibende Methoden mit \code{wait}, aber ohne \code{notify}/\code{notifyAll}
    \item schreibende Methoden ohne \code{wait}, aber mit \code{notify}/\code{notifyAll}
    \item schreibende Methoden mit \code{wait} und mit \code{notify}/\code{notifyAll}
\end{itemize}










